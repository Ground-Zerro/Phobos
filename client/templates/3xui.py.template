#!/usr/bin/env python3

import json
import re
import sys
import sqlite3
import subprocess
from pathlib import Path
from typing import Dict, Optional, Tuple


class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


def print_status(message: str, status: str = "info"):
    colors = {
        "success": Colors.GREEN + "‚úì",
        "error": Colors.RED + "‚úó",
        "warning": Colors.YELLOW + "‚ö†",
        "info": Colors.BLUE + "‚Ñπ",
        "debug": Colors.CYAN + "üîç"
    }
    print(f"{colors.get(status, '')} {message}{Colors.RESET}")


def get_default_xray_config() -> Dict:
    return {
        "api": {
            "services": [
                "HandlerService",
                "StatsService",
                "LoggerService"
            ],
            "tag": "api"
        },
        "inbounds": [
            {
                "listen": "127.0.0.1",
                "port": 62789,
                "protocol": "dokodemo-door",
                "settings": {
                    "address": "127.0.0.1"
                },
                "tag": "api"
            }
        ],
        "outbounds": [
            {
                "protocol": "freedom",
                "settings": {},
                "tag": "direct"
            },
            {
                "protocol": "blackhole",
                "settings": {},
                "tag": "block"
            }
        ],
        "policy": {
            "levels": {
                "0": {
                    "statsUserDownlink": True,
                    "statsUserUplink": True
                }
            },
            "system": {
                "statsInboundDownlink": True,
                "statsInboundUplink": True,
                "statsOutboundDownlink": True,
                "statsOutboundUplink": True
            }
        },
        "routing": {
            "domainStrategy": "AsIs",
            "rules": [
                {
                    "inboundTag": [
                        "api"
                    ],
                    "outboundTag": "api",
                    "type": "field"
                },
                {
                    "ip": [
                        "geoip:private"
                    ],
                    "outboundTag": "block",
                    "type": "field"
                }
            ]
        },
        "stats": {}
    }


def check_jq_available() -> bool:
    try:
        result = subprocess.run(['jq', '--version'],
                              capture_output=True,
                              text=True,
                              timeout=5)
        if result.returncode == 0:
            print_status(f"jq –Ω–∞–π–¥–µ–Ω: {result.stdout.strip()}", "success")
            return True
        return False
    except (subprocess.SubprocessError, FileNotFoundError):
        print_status("jq –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ", "warning")
        return False


def jq_format_json(json_data: str) -> Optional[str]:
    try:
        result = subprocess.run(
            ['jq', '.'],
            input=json_data,
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode == 0:
            return result.stdout
        return None
    except Exception:
        return None


def parse_wireguard_conf(config_path: str) -> Dict:
    config = {'interface': {}, 'peer': {}}
    current_section = None

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                if line.startswith('[') and line.endswith(']'):
                    current_section = line[1:-1].lower()
                    continue

                if '=' in line and current_section:
                    key, value = line.split('=', 1)
                    key, value = key.strip(), value.strip()

                    if current_section == 'interface':
                        config['interface'][key] = value
                    elif current_section == 'peer':
                        if key == 'AllowedIPs' and ',' in value:
                            config['peer'][key] = [ip.strip() for ip in value.split(',')]
                        else:
                            config['peer'][key] = value

        return config

    except FileNotFoundError:
        print_status(f"–§–∞–π–ª {config_path} –Ω–µ –Ω–∞–π–¥–µ–Ω", "error")
        sys.exit(1)
    except Exception as e:
        print_status(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}", "error")
        sys.exit(1)


def extract_endpoint_info(endpoint: str) -> Tuple[str, int]:
    if '[' in endpoint:
        match = re.match(r'\[([^\]]+)\]:(\d+)', endpoint)
        if match:
            return match.group(1), int(match.group(2))
    else:
        parts = endpoint.rsplit(':', 1)
        if len(parts) == 2:
            return parts[0], int(parts[1])

    return endpoint, 51820


def convert_to_xray_outbound(wg_config: Dict, tag: str = "Phobos") -> Dict:
    interface = wg_config.get('interface', {})
    peer = wg_config.get('peer', {})

    endpoint = peer.get('Endpoint', '')
    server_address, server_port = extract_endpoint_info(endpoint)

    addresses = interface.get('Address', '').split(',')

    local_addresses = []
    for addr in addresses:
        addr = addr.strip()
        if not addr:
            continue

        if '/' in addr:
            ip_part = addr.split('/')[0]
            if ':' in ip_part:
                local_addresses.append(f"{ip_part}/128")
            else:
                local_addresses.append(f"{ip_part}/32")
        else:
            if ':' in addr:
                local_addresses.append(f"{addr}/128")
            else:
                local_addresses.append(f"{addr}/32")

    allowed_ips_raw = peer.get('AllowedIPs', [])
    if isinstance(allowed_ips_raw, str):
        allowed_ips = [ip.strip() for ip in allowed_ips_raw.split(',') if ip.strip()]
    elif isinstance(allowed_ips_raw, list):
        allowed_ips = allowed_ips_raw
    else:
        allowed_ips = ['0.0.0.0/0', '::/0']

    if not allowed_ips:
        allowed_ips = ['0.0.0.0/0', '::/0']

    peer_config = {
        "publicKey": peer.get('PublicKey', ''),
        "allowedIPs": allowed_ips,
        "endpoint": f"{server_address}:{server_port}"
    }

    keep_alive = peer.get('PersistentKeepalive', '0')
    if keep_alive and int(keep_alive) > 0:
        peer_config["keepAlive"] = int(keep_alive)

    if 'PresharedKey' in peer or 'PreSharedKey' in peer:
        psk = peer.get('PresharedKey') or peer.get('PreSharedKey')
        if psk:
            peer_config["preSharedKey"] = psk

    mtu = interface.get('MTU', '1420')

    settings = {
        "mtu": int(mtu) if mtu else 1420,
        "secretKey": interface.get('PrivateKey', ''),
        "address": local_addresses if local_addresses else [],
        "workers": 2,
        "peers": [peer_config],
        "noKernelTun": False
    }

    outbound = {
        "protocol": "wireguard",
        "settings": settings,
        "tag": tag
    }

    return outbound


def find_database() -> Optional[str]:
    common_paths = [
        "/etc/x-ui/x-ui.db",
        "/usr/local/x-ui/x-ui.db",
        "/opt/x-ui/x-ui.db",
        "./x-ui.db"
    ]

    for path in common_paths:
        if Path(path).exists():
            print_status(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞–π–¥–µ–Ω–∞: {path}", "success")
            return path

    return None


def diagnose_database(db_path: str) -> Optional[str]:
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        print_status(f"–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã: {[t[0] for t in tables]}", "debug")

        if ('settings',) in tables:
            cursor.execute("SELECT key FROM settings")
            keys = cursor.fetchall()
            print_status(f"–ö–ª—é—á–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ settings: {[k[0] for k in keys]}", "debug")

            possible_keys = [
                'xrayTemplateConfig',
                'xrayConfig',
                'xray_config',
                'config'
            ]

            for key in possible_keys:
                cursor.execute("SELECT value FROM settings WHERE key = ?", (key,))
                result = cursor.fetchone()
                if result:
                    print_status(f"–ù–∞–π–¥–µ–Ω –∫–ª—é—á –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {key}", "success")
                    conn.close()
                    return key

        conn.close()
        return None

    except Exception as e:
        print_status(f"–û—à–∏–±–∫–∞ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ë–î: {e}", "error")
        return None


def create_xray_config_in_db(db_path: str, outbound: Dict) -> bool:
    print_status("–°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Xray...", "info")

    conn = None
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        base_config = get_default_xray_config()

        base_config['outbounds'].insert(0, outbound)

        config_json = json.dumps(base_config, ensure_ascii=False, indent=2)

        json.loads(config_json)

        config_key = 'xrayTemplateConfig'

        cursor.execute("SELECT value FROM settings WHERE key = ?", (config_key,))
        exists = cursor.fetchone()

        if exists:
            print_status(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–ª—é—á–∞ {config_key}", "info")
            cursor.execute(
                "UPDATE settings SET value = ? WHERE key = ?",
                (config_json, config_key)
            )
        else:
            print_status(f"–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫–ª—é—á–∞ {config_key}", "info")
            cursor.execute(
                "INSERT INTO settings (key, value) VALUES (?, ?)",
                (config_key, config_json)
            )

        conn.commit()

        print_status("–ë–∞–∑–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Xray —Å–æ–∑–¥–∞–Ω–∞", "success")
        print_status(f"Outbound '{outbound['tag']}' –¥–æ–±–∞–≤–ª–µ–Ω", "success")

        return True

    except Exception as e:
        if conn:
            conn.rollback()
        print_status(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}", "error")
        return False
    finally:
        if conn:
            conn.close()


def import_via_database(outbound: Dict, db_path: str, interactive: bool = True) -> bool:
    print_status("–ü–æ–ø—ã—Ç–∫–∞ –ø—Ä—è–º–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö...", "info")

    if not Path(db_path).exists():
        print_status(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {db_path}", "error")
        return False

    print_status(f"–†–∞–±–æ—Ç–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö: {db_path}", "info")

    config_key = diagnose_database(db_path)

    if not config_key:
        print_status("–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Xray –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö", "warning")
        return create_xray_config_in_db(db_path, outbound)

    conn = None
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        cursor.execute(f"SELECT value FROM settings WHERE key = ?", (config_key,))
        result = cursor.fetchone()

        if not result:
            print_status("–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Xray –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ", "error")
            return False

        config_json = result[0]

        try:
            config = json.loads(config_json)
        except json.JSONDecodeError as e:
            print_status(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}", "error")
            return False

        if 'outbounds' not in config:
            config['outbounds'] = []

        existing_tags = [ob.get('tag') for ob in config.get('outbounds', [])]
        tag_exists = outbound['tag'] in existing_tags

        if tag_exists:
            print_status(f"Outbound —Å —Ç–µ–≥–æ–º '{outbound['tag']}' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∑–∞–º–µ–Ω—è—é", "warning")
            config['outbounds'] = [
                ob for ob in config['outbounds']
                if ob.get('tag') != outbound['tag']
            ]

        config['outbounds'].insert(0, outbound)

        final_config = json.dumps(config, ensure_ascii=False, indent=2)

        json.loads(final_config)

        cursor.execute(
            f"UPDATE settings SET value = ? WHERE key = ?",
            (final_config, config_key)
        )

        conn.commit()

        print_status("Outbound —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö", "success")

        return True

    except Exception as e:
        if conn:
            conn.rollback()
        print_status(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö: {e}", "error")
        import traceback
        traceback.print_exc()
        return False
    finally:
        if conn:
            conn.close()


def restart_xui_service() -> bool:
    print_status("–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ x-ui...", "info")

    try:
        result = subprocess.run(
            ['systemctl', 'restart', 'x-ui'],
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode == 0:
            print_status("–°–µ—Ä–≤–∏—Å x-ui —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω", "success")

            status_result = subprocess.run(
                ['systemctl', 'is-active', 'x-ui'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if status_result.returncode == 0 and status_result.stdout.strip() == 'active':
                print_status("–°–µ—Ä–≤–∏—Å x-ui –∞–∫—Ç–∏–≤–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç", "success")
                return True
            else:
                print_status("–°–µ—Ä–≤–∏—Å x-ui –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω, –Ω–æ —Å—Ç–∞—Ç—É—Å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω", "warning")
                print_status("–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å: systemctl status x-ui", "info")
                return True
        else:
            print_status(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: {result.stderr}", "error")
            return False

    except subprocess.TimeoutExpired:
        print_status("–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ —Å–µ—Ä–≤–∏—Å–∞", "error")
        return False
    except FileNotFoundError:
        print_status("systemctl –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—ã—Ç–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞...", "warning")

        alternative_commands = [
            ['service', 'x-ui', 'restart'],
            ['/etc/init.d/x-ui', 'restart'],
            ['x-ui', 'restart']
        ]

        for cmd in alternative_commands:
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                if result.returncode == 0:
                    print_status(f"–°–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω —á–µ—Ä–µ–∑ {' '.join(cmd)}", "success")
                    return True
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue

        print_status("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏", "error")
        print_status("–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –≤—Ä—É—á–Ω—É—é: systemctl restart x-ui", "info")
        return False
    except Exception as e:
        print_status(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ: {e}", "error")
        return False


def check_xui_logs() -> None:
    print_status("–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–æ–≤ x-ui...", "info")

    try:
        result = subprocess.run(
            ['journalctl', '-u', 'x-ui', '-n', '20', '--no-pager'],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode == 0:
            logs = result.stdout

            error_keywords = ['error', 'failed', 'fatal', 'panic']
            has_errors = any(keyword in logs.lower() for keyword in error_keywords)

            if has_errors:
                print_status("–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—à–∏–±–∫–∏ –≤ –ª–æ–≥–∞—Ö:", "warning")
                print(logs[-500:])
            else:
                print_status("–õ–æ–≥–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç —è–≤–Ω—ã—Ö –æ—à–∏–±–æ–∫", "success")

    except Exception:
        print_status("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ª–æ–≥–∏", "debug")


def main():
    print(f"\n{Colors.BOLD}=== WireGuard to 3x-ui Auto-Import Tool ==={Colors.RESET}\n")

    use_jq = check_jq_available()

    if not use_jq:
        print_status("–†–∞–±–æ—Ç–∞ –±—É–¥–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∞ –±–µ–∑ jq (–∏—Å–ø–æ–ª—å–∑—É—è Python)", "info")

    print()

    if len(sys.argv) < 2:
        config_path = input("–ü—É—Ç—å –∫ wireguard.conf: ").strip()
    else:
        config_path = sys.argv[1]

    print_status(f"–ü–∞—Ä—Å–∏–Ω–≥ {config_path}...", "info")
    wg_config = parse_wireguard_conf(config_path)

    print_status("–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ Xray —Ñ–æ—Ä–º–∞—Ç...", "info")
    outbound = convert_to_xray_outbound(wg_config, tag="Phobos")

    print(f"\n{Colors.BOLD}–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è outbound:{Colors.RESET}")

    outbound_json = json.dumps(outbound, indent=2, ensure_ascii=False)

    if use_jq:
        formatted = jq_format_json(outbound_json)
        if formatted:
            print(formatted)
        else:
            print(outbound_json)
    else:
        print(outbound_json)

    print()

    print_status("–ò–º–ø–æ—Ä—Ç –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö 3x-ui...", "info")

    db_path = "/etc/x-ui/x-ui.db"

    if not Path(db_path).exists():
        print_status(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –ø–æ –ø—É—Ç–∏: {db_path}", "warning")
        found_db = find_database()
        if found_db:
            db_path = found_db
        else:
            print_status("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö", "error")
            print_status("–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ 3x-ui —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", "info")
            sys.exit(1)

    success = False
    if Path(db_path).exists():
        success = import_via_database(outbound, db_path, interactive=False)

    if not success:
        print_status("–ò–º–ø–æ—Ä—Ç –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –Ω–µ —É–¥–∞–ª—Å—è", "error")
        sys.exit(1)

    output_path = config_path.rsplit('.', 1)[0] + '_3xui_outbound.json'
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            if use_jq:
                formatted = jq_format_json(outbound_json)
                f.write(formatted if formatted else outbound_json)
            else:
                f.write(outbound_json)
        print_status(f"JSON —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤: {output_path}", "success")
    except Exception as e:
        print_status(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}", "error")

    print()

    restart_success = restart_xui_service()

    if restart_success:
        import time
        time.sleep(2)

        check_xui_logs()

    print()
    print_status("–ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!", "success")
    print()
    print_status(f"{Colors.BOLD}–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:{Colors.RESET}", "info")
    print_status(f"‚Ä¢ Outbound 'Phobos' –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é", "info")
    print_status(f"‚Ä¢ –°–µ—Ä–≤–∏—Å x-ui {'–ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω' if restart_success else '—Ç—Ä–µ–±—É–µ—Ç –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞'}", "info")
    print_status(f"‚Ä¢ JSON –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {output_path}", "info")
    print()
    print_status(f"{Colors.BOLD}–ü—Ä–æ–≤–µ—Ä–∫–∞:{Colors.RESET}", "info")
    print_status("‚Ä¢ –û—Ç–∫—Ä–æ–π—Ç–µ –≤–µ–±-–ø–∞–Ω–µ–ª—å 3x-ui", "info")
    print_status("‚Ä¢ –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª Outbounds", "info")
    print_status("‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ outbound 'Phobos' –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç", "info")

    if not restart_success:
        print()
        print_status(f"{Colors.BOLD}–¢—Ä–µ–±—É–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏–µ:{Colors.RESET}", "warning")
        print_status("–í—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Ä—É—á–Ω—É—é: systemctl restart x-ui", "warning")

    print()


if __name__ == "__main__":
    main()
